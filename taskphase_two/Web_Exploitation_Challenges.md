# picoCTF Web Exploitation Challenges 
### Inspect HTML 
```
Launching the challenge instance, we are given a link to a website with a simple format. Left-clicking and viewing the page source, we get the flag. 
flag=picoCTF{1n5p3t0r_0f_h7ml_8113f7e2}
```
![image](https://github.com/user-attachments/assets/859d892c-bee0-4b68-b8fd-aa5ae1b47f3b)

### Intro to Burp
```
To solve this challenge, we need to use an application called BurpSuite. Installing the app and launching the chromium browser built into the app, we launch the link given by the challenge. Enter random values into the text fields, we get the invalid OTP screen. In BurpSuite, we go to the Proxy tab and look at this. 
```
![image](https://github.com/user-attachments/assets/0ebd2ce9-08b8-4ef5-b89a-546713bafb43)
```
Now, we sort the processes by time and click on the last process, which is POST. This opens two tabs, Request and Response. Here we can see the text I entered into the OTP field. 
```
![image](https://github.com/user-attachments/assets/f90ba729-5928-4f50-b3b2-a8ff5f2a6a96)
```
Now, we go to the Repeater tab, and bypass the otp field by setting it to something, in this case, its garbage. This gives us the flag. 
flag= picoCTF{#0TP_Bypvss_SuCc3$S_2e80f1fd}
```
![image](https://github.com/user-attachments/assets/67edddb8-4504-4489-a44f-21dca17e17a0)

### Dont-use-client-side
```
Opening the website link given, and viewing the page source, we see that the flag is divided into 8 parts. Piecing them together, we get the answer.
flag=picoCTF{no_clients_plz_b706c5}

```
![image](https://github.com/user-attachments/assets/43c7d357-3a44-4005-8d3b-f89908c0429d)

### Where are the robots 
```
In this challenge, we use the hint given to add robots.txt at the end of the given url, something like this: 
```
![image](https://github.com/user-attachments/assets/eec51afd-20e4-4c9e-959e-3a7b3aef5bcd)
```
Now, going to the url ending with robots.txt, we get a .html extension, which when added to the end of the url gives us the flag. 
flag=picoCTF{ca1cu1at1ng_Mach1n3s_1bb4c}
```
![image](https://github.com/user-attachments/assets/f16e7298-6a1d-4500-b291-51c54382d677)

### Sql Direct 
```
Launching the challenge and using the webshell because I don't have PSQL installed on my WSL, we use the command psql -h saturn.picoctf.net -p 52120 -U postgres pico with the password postgres to connect to the PSQL database with its command line interface. Once we are connected, we use the command \dt to show all the tables present. After doing that, we see that theres a table named flags, we can access all the data in that using select * from flags;. Doing this, we get the flag. 
flag=picoCTF{L3arN_S0m3_5qL_t0d4Y_21c94904}
```
![image](https://github.com/user-attachments/assets/841f13ea-3334-4e67-9172-10f3d25cbc57)

### Some assembly required 1
```
In this challenge, opening the link, we get a simple text box with a prompt to enter the flag. Inspecting this page and going to sources, we see this
```
![image](https://github.com/user-attachments/assets/716f5c92-9ea4-42ed-9267-7f0fd9050b07)
```
Now, we go to the file listed under Wasm, (Wasm is a portable compilation target for programming languages). Scrolling to the bottom, we find the flag.
flag=picoCTF{d88090e679c48f3945fcaa6a7d6d70c5}
```

### Power Cookie
```
This challenge requires the use of BurpSuite tools. Once we open the website in the browser included with Burp, we go to the proxy tab to see all the requests and responses. We see that there's an option called isAdmin, which is initially set to 0, sending this request to repeater and setting it to 1, we get the flag. 
flag=picoCTF{gr4d3_A_c00k13_65fd1e1a}
```

### Most Cookies 
```

```

### More SQLi
```

```